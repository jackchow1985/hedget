<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLROjXfSpIU_1TsQlCJ7q4WkfnUSgpG7o6Yx3LgtCQhIzcgkv6_KOpC-vO9QMy-VQCA');ol{margin:0;padding:0}table td,table th{padding:0}.c42{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:92.2pt;border-top-color:#000000;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:289.5pt;border-top-color:#000000;border-bottom-style:solid}.c14{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:86.2pt;border-top-color:#000000;border-bottom-style:solid}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c50{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c10{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#6897bb;font-weight:400}.c15{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#cc7832;font-weight:700}.c16{background-color:#2b2b2b;color:#a5c261;font-weight:400;font-size:9pt;font-family:"Consolas"}.c23{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#cc7832;font-weight:400}.c17{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;text-align:left}.c21{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#aa4926;font-weight:400}.c32{background-color:#434343;font-size:9pt;font-family:"Consolas";color:#a5c261;font-weight:400}.c26{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:left}.c2{background-color:#434343;font-size:9pt;font-family:"Consolas";color:#cc7832;font-weight:400}.c34{background-color:#40332b;font-size:9pt;font-family:"Consolas";color:#a9b7c6;font-weight:400}.c22{background-color:#434343;color:#808080;font-weight:400;font-size:9pt;font-family:"Consolas"}.c36{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#808080;font-weight:400}.c11{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#8888c6;font-weight:400}.c37{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#b200b2;font-weight:400}.c1{background-color:#2b2b2b;font-size:9pt;font-family:"Consolas";color:#a9b7c6;font-weight:400}.c38{background-color:#434343;font-size:9pt;font-family:"Consolas";color:#b200b2;font-weight:400}.c8{background-color:#434343;font-size:9pt;font-family:"Consolas";color:#6897bb;font-weight:400}.c25{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c0{background-color:#434343;font-size:9pt;font-family:"Consolas";color:#a9b7c6;font-weight:400}.c41{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c28{background-color:#434343;font-size:9pt;font-family:"Consolas";color:#aa4926;font-weight:400}.c9{color:#000000;font-weight:700;font-size:11pt;font-family:"Consolas"}.c13{color:#000000;font-weight:400;font-size:9pt;font-family:"Arial"}.c39{border-spacing:0;border-collapse:collapse;margin-right:auto}.c24{color:#000000;font-weight:400;font-size:9pt;font-family:"Consolas"}.c12{color:#000000;font-weight:400;font-size:16pt;font-family:"Arial"}.c19{color:#434343;font-weight:400;font-size:14pt;font-family:"Arial"}.c7{text-decoration:none;vertical-align:baseline;font-style:normal}.c51{background-color:#434343;font-size:9pt;color:#8888c6}.c52{color:#000000;font-weight:400;font-size:26pt}.c20{background-color:#434343;font-size:9pt;color:#cc7832}.c46{background-color:#2b2b2b;font-size:9pt;color:#a9b7c6}.c33{background-color:#434343;font-size:9pt;color:#a9b7c6}.c49{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c43{color:#1155cc;text-decoration:underline}.c30{font-weight:400;font-family:"Calibri"}.c31{color:#000000;font-size:11pt}.c35{font-weight:700;font-family:"Calibri"}.c44{font-weight:400;font-family:"Consolas"}.c47{color:inherit;text-decoration:inherit}.c18{font-weight:700;font-family:"Consolas"}.c27{background-color:#fff2cc}.c40{height:0pt}.c5{height:11pt}.c48{font-family:"Arial"}.c45{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c49"><p class="c26 title" id="h.w0wp6sxu425u"><span class="c7 c48 c52">FDT-BT</span></p><p class="c4"><span class="c3">update log</span></p><p class="c4"><span class="c3">version: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1</span></p><p class="c4"><span class="c3">author: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guowen</span></p><p class="c4"><span class="c3">changes: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialize</span></p><h1 class="c41" id="h.g3ur7atfiyiz"><span class="c6">Documents</span></h1><h2 class="c25" id="h.1m8rqvpaz3uk"><span class="c12 c7">1 Framework</span></h2><p class="c4"><span class="c3">1.1 This backtesting platform is based on pyalgotrade for its efficiency and convenience to redevelopment. The details of comparison between zipline and pyalgotrade is presented in Zipline_vs_pyalgotrade.pptx. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span>1.2 The data input is modified from csv file to DataFrame from mongo by adding a method </span><span class="c18">addBarsFromDataFrame()</span><span>&nbsp;to </span><span>GenericBarFeed</span><span>&nbsp;(the modification on </span><span>pyalgotrade/barfeed/csvfeed.py</span><span class="c3">&nbsp;is marked explicitly). </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span>1.3 Method </span><span class="c18">getValues()</span><span>&nbsp;is added to </span><span>SequenceDataSeries</span><span>&nbsp;(</span><span>pyalgotrade/dataseries/__init__.py</span><span>) for the sake of converting DataSeries to list. </span><span class="c18">DataSeries.getDateTimes()</span><span>&nbsp;&rarr; list of date time, </span><span class="c18">DataSeries.getValues()</span><span class="c3">&nbsp;&rarr; list of values. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">1.4 A bridge (super_strat) is built between user strategy and the BacktestingStrategy class for the sake of flexibility, so the user interface will not be affected even if we upgrade the frame. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">1.5 super_strat is inherited from BacktestingStrategy, and the platform related methods are defined in it. sub_strat is inherited from super_strat and it contains the user strategy. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">1.6 All the data used in the strategy is fetched from mongo completely before strategy runs. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">1.7 If the strategy is based on single instrument, any missing point in the price fetched from </span></p><p class="c4"><span class="c3">mongo does not matter. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">1.8 If the strategy is based on multiple instruments, pyalgotrade has the request that the time axis of each instrument must be exactly the same. If one instrument has a missing data point at 2017-04-19, we must remove data at 2017-04-19 in other instruments. So there is a matching procedure before feed data into pyalgotrade. The work flow is as following:</span></p><p class="c4"><span class="c7 c31 c45 c48">Fetch data from mongo &rarr; delete the data at non-common time point &rarr; feed data into pyalgotrade </span></p><p class="c4 c5"><span class="c7 c31 c48 c45"></span></p><p class="c4"><span>1.9 one position-adjusting function is implemented, which is </span><span class="c9 c7">self.marketOrderTargetPercent(percentage_dict, position_rate)</span></p><p class="c4"><span class="c18">position_rate = 0.9</span><span>&nbsp;means that 90% of the total portfolio is used to fill the position scheme defined in </span><span class="c18">percentage_dict</span><span class="c3">:</span></p><p class="c4"><span class="c9 c7">percentage_dict = {&lsquo;000001.SH&rsquo;, 0.3, </span></p><p class="c4"><span class="c9 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lsquo;000002.SH&rsquo;, 0.3, </span></p><p class="c4"><span class="c9 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lsquo;000003.SH&rsquo;, 0.4}</span></p><p class="c4 c5"><span class="c7 c31 c44"></span></p><h2 class="c25" id="h.dflgdjxs0e3l"><span class="c12 c7">2 Items</span></h2><p class="c4"><span class="c3">Path: 03:/home/guowen/bldserver_2</span></p><p class="c4"><span class="c3">Currently the files are uploaded to this folder:</span></p><p class="c4"><span class="c3">2.1 user_provide.py &rarr; the code provided by the user, including backtesting parameters, and the strategy (this file is generated by the web). </span></p><p class="c4"><span class="c3">2.2 sys_provide.py &rarr; the code defining the bridge class (super_strat). </span></p><p class="c4"><span class="c3">2.3 construct.py &rarr; run this to convert user_provide.py to real strategy file strat_file.py. </span></p><p class="c4"><span class="c3">2.4 bld_run.py &rarr; fetch the data and instantiate the strategy and run, eventually print json results. </span></p><p class="c4"><span class="c3">2.5 the output will be trading transactions and portfolio printed with json format. . </span></p><p class="c4 c5"><span class="c3"></span></p><h2 class="c25" id="h.58ibdqt7jpnj"><span class="c12 c7">3 Operation</span></h2><p class="c4"><span class="c3">3.1 write the user defined strategy and corresponding parameters into user_provide.py </span></p><p class="c4"><span>3.2 </span><span class="c18">python construct.py </span><span class="c3">&rarr; to generate the strategy file strat_file.py</span></p><p class="c4"><span>3.3 </span><span class="c18">python bld_run.py</span><span class="c3">&nbsp;&rarr; to fetch data from mongo and run the strategy </span></p><p class="c4 c5"><span class="c3"></span></p><h1 class="c41" id="h.2at50uuj7mg8"><span class="c6">Tutorial</span></h1><p class="c4"><span class="c3">The backtesting strategy consists of three parts:</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 415.95px; height: 454.50px;"><img alt="" src="images/image1.png" style="width: 415.95px; height: 454.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c25" id="h.vub2178fefwg"><span class="c7 c12">1 backtesting parameters</span></h2><p class="c4"><span class="c3">First you must specify some parameters for your backtesting. </span></p><p class="c4"><span class="c9 c7">frequency = &#39;DAY&#39;</span></p><p class="c4"><span class="c9 c7">start = &#39;2016-01-01&#39;</span></p><p class="c4"><span class="c9 c7">end = &#39;2016-12-31&#39;</span></p><p class="c4"><span class="c9 c7">instrument = [&#39;601398.SH&#39;]</span></p><p class="c4"><span class="c9 c7">cash = 100000.0</span></p><p class="c4"><span class="c9 c7">commission = 0.001</span></p><p class="c4"><span class="c9 c7">slippage = 0.1</span></p><p class="c4 c5"><span class="c3 c27"></span></p><a id="t.c099c61e2508aacc0c432408a78941acd54f87c4"></a><a id="t.0"></a><table class="c39"><tbody><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span>frequency</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span>&nbsp;&#39;DAY&#39;</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c4"><span class="c3">bar frequency: &lsquo;DAY&rsquo;, &lsquo;MINUTE&rsquo;</span></p></td></tr><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span>start</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span>&#39;2016-01-01&#39;</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c50"><span class="c3">start date like this or minute &#39;2017-05-05 14:51:00&#39;</span></p></td></tr><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span>end</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span>&#39;2016-01-01&#39;</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c4"><span class="c3">end date or minute</span></p></td></tr><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span>instrument</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span>[&#39;601398.SH&#39;]</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c4"><span class="c3">[&#39;601398.SH, &lsquo;000001.SZ&#39;]</span></p></td></tr><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span>cash</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span>100000.0</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c4"><span class="c3">Initial cash in hand</span></p></td></tr><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span class="c3">commission</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span class="c3">0.001</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c4"><span class="c3">The commission fee is 0.1% of the turnover</span></p></td></tr><tr class="c40"><td class="c14" colspan="1" rowspan="1"><p class="c4"><span class="c3">slippage</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c4"><span class="c3">0.1</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c4"><span class="c3">Parameter for the VolumeShareSlippage model </span></p></td></tr></tbody></table><p class="c4 c5"><span class="c3 c27"></span></p><h2 class="c25" id="h.dtc27a55d38k"><span class="c12 c7">2 __init__() &rarr; data feed (class variables)</span></h2><p class="c4"><span class="c3">Data declared or defined in this region will exist during the entire backtesting process, and can be visited and modified at any loop. </span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.osh57mc42a3f"><span class="c19 c7">2.1 instruments &rarr; the list you defined in the parameters</span></h3><p class="c4"><span class="c18">self.__instrument = instrument </span><span class="c3">&rarr; a list same as instrument</span></p><p class="c4"><span class="c18">self.__instrument = instrument[0]</span><span class="c3">&nbsp;&rarr; one instrument </span></p><p class="c4"><span class="c18">self.__icbc = instrument[0]</span><span class="c3">&nbsp;&rarr; one instrument</span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.rpmqata7606o"><span class="c19 c7">2.2 The bar data to support your backtest. </span></h3><p class="c4"><span>The underlying data structure is </span><span class="c18">SequenceDataSeries</span><span class="c3">, which is implemented by deque of datetime and price. </span></p><p class="c4"><span class="c18">feed</span><span class="c3">&nbsp;&rarr; contain all bar data from start date to end date of all instruments</span></p><p class="c4"><span class="c18">feed[one_instrument]</span><span>&nbsp;will return object of &nbsp;</span><span>BarDataSeries</span><span class="c3">, which is a series of bars. </span></p><p class="c4"><span class="c18">self.__close = feed[one_instrument].getCloseDataSeries()</span><span class="c18">&nbsp;</span><span>&rarr; return </span><span>SequenceDataSeries with</span><span>&nbsp;close price, and you can change to &rarr; </span><span class="c18">getHigh&hellip; getLow&hellip; getOpen&hellip; getVolume&hellip; </span></p><p class="c4"><span>SequenceDataSeries</span><span>&nbsp;is a combination of time and price. It is very convenient to calculate indicators by bulit-in function and TA-Lib. The </span><span>SequenceDataSeries</span><span>&nbsp;is also list-like, so you can visit the price data via </span><span class="c18">self.__close[-10:]</span><span>, the same way as list. You can also obtain the list of time and price by </span><span class="c18">SequenceDataSeries.getDateTimes()</span><span>&nbsp;and </span><span class="c18">getValues()</span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.dhremanghie7"><span class="c7 c19">2.3 user defined class variable</span></h3><p class="c4"><span class="c3">You can also define some class virables for specific usage, e.g. track the number of iterations which have been made, or track the highest price of one instrument. </span></p><p class="c4"><span class="c18">self.__loop = 0</span><span class="c3">, then increment one at each iteration. </span></p><p class="c4"><span class="c18">self.__highest_price = 0</span><span class="c3">, then </span></p><p class="c4"><span class="c9 c7">if curr_price &gt; self.__highest_price: </span></p><p class="c4"><span class="c18">&nbsp; &nbsp; self.__highest_price = curr_price</span><span class="c3">&nbsp;</span></p><p class="c4"><span class="c3">at each iteration. </span></p><p class="c4 c5"><span class="c3"></span></p><h2 class="c25" id="h.toj0ks63t562"><span class="c12 c7">3 onBars() &rarr; iteration on each bar</span></h2><p class="c4"><span class="c3">The onBars() will iterate on each new time point, variables defined in this region are local to the current iteration. </span></p><p class="c4"><span class="c3">What do you need to run your strategy?</span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.kmpzi8mrj01f"><span class="c19 c7">3.1 current date and time</span></h3><p class="c4"><span class="c3">self.getCurrentDateTime()</span></p><p class="c4"><span class="c3">bars.getDateTime()</span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.ij3zjsmgcna"><span class="c19 c7">3.2 latest price of one instrument (frequently used)</span></h3><p class="c4"><span class="c18">self.__close[-1]</span><span class="c3">&nbsp;</span></p><p class="c4"><span class="c18">bars[one_instrument].getClose()</span><span class="c3">&nbsp;</span></p><p class="c4"><span class="c18">self.getLastPrice[one_instrument]</span><span class="c3">&nbsp;</span></p><p class="c4"><span class="c3">return the last price of one instrument </span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.zhdrn8merm00"><span class="c19 c7">3.3 price sequence</span></h3><p class="c4"><span class="c18">s</span><span class="c18">elf.__close</span><span>, &nbsp;you can at most visit the price of current day, so </span><span class="c18">self.__close[-1]</span><span>&nbsp;is always today&rsquo;s price, and the histoty price can be acquired by </span><span class="c18">self.__close[-10: ]</span><span class="c3">. We recommand this way to acquired price data, because the entire sequence is already ready to use in memory before the strategy runs, thus it is fast. </span></p><p class="c4"><span class="c18">self.getFeed()[one_instrument].getCloseDataSeries()</span><span class="c3">&nbsp;can also be called to acquire the price sequence, but this in-loop operation will create and destroy the SequenceDataSeries over and over, which takes time. </span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.5v37g2jb4wfr"><span class="c19 c7">3.4 the current account information is stored in Broker</span></h3><p class="c4"><span class="c18">self.getBroker() </span><span class="c3">&rarr; return the Broker</span></p><p class="c4"><span class="c18">self.getBroker().getCash()</span><span class="c3">&nbsp;&rarr; return the current available cash</span></p><p class="c4"><span class="c18">self.getBroker().getShares(one_instrument) </span><span class="c3">&rarr; return holding shares of one instrument</span></p><p class="c4"><span class="c18">self.getBroker().getPosition() </span><span class="c3">&rarr; return a dictionary that maps instruments to shares. Causion: the dictionary is empty if the number of holding shares is 0.</span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.r29judxqnppy"><span class="c19 c7">3.5 order placement </span></h3><p class="c4"><span class="c18">self.marketOrder(one_instrument, 100, goodTillCanceled=True)</span><span>&nbsp;&rarr; place market order, which will be filled in the next trading day at open price (</span><span class="c18">onClose = False</span><span>) or close price (</span><span class="c18">onClose = True</span><span class="c3">) </span></p><p class="c4"><span>Also, you can place </span><span class="c18">limitOrder, stopOrder, stopLimitOrder</span><span class="c3">. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c18">self.marketOrderTargetPercent(percentage_dict, 0.9) </span><span class="c45">&rarr;</span><span class="c18">&nbsp;</span><span class="c35">&nbsp;</span><span class="c7 c30 c31">adjust the current positions</span></p><p class="c4"><span class="c30">adjust 90% of total portfolio to the positions defined in </span><span class="c18">percentage_dict</span><span class="c7 c30 c31">.</span></p><p class="c4"><span class="c9 c7">percentage_dict = {&lsquo;000001.SH&rsquo;: 0.3,</span></p><p class="c4"><span class="c9 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lsquo;000002.SH&rsquo;: 0.3,</span></p><p class="c4"><span class="c9 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lsquo;000003.SH&rsquo;: 0.4 }</span></p><p class="c4 c5"><span class="c9 c7"></span></p><h2 class="c25" id="h.83m1qtuz20z1"><span class="c12 c7">4 let&rsquo;s practice with single instrument strategy! </span></h2><p class="c4"><span class="c9 c7">frequency = &#39;DAY&#39;</span></p><p class="c4"><span class="c9 c7">start = &#39;2016-01-01&#39;</span></p><p class="c4"><span class="c9 c7">end = &#39;2016-12-31&#39;</span></p><p class="c4"><span class="c9 c7">instrument = [&#39;601398.SH&#39;]</span></p><p class="c4"><span class="c9 c7">cash = 100000.0</span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">These are the parameters above the __init__(), we do not need to change it while modifying the functionality of the strategy. So now we focus on the body of the strategy. </span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.baloil2ifaar"><span class="c19 c7">4.1 print the price data</span></h3><p class="c4"><span class="c20 c18">def </span><span class="c38">__init__</span><span class="c0">(self</span><span class="c2">, </span><span class="c0">feed</span><span class="c2">, </span><span class="c0 c7">instrument):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.__instrument = instrument[</span><span class="c8">0</span><span class="c0 c7">]</span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;self.__close = feed[self.__instrument].getCloseDataSeries()</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c20 c18">def </span><span class="c33 c18">onBars</span><span class="c0">(self</span><span class="c2">, </span><span class="c0 c7">bars):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;bar = bars[self.__instrument]</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.info(</span><span class="c32">&#39;open : %.2f, high : %.2f, low : %.2f, close : %.2f&#39; </span><span class="c0 c7">%</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(bar.getOpen()</span><span class="c2">, </span><span class="c0">bar.getHigh()</span><span class="c2">, </span><span class="c0">bar.getLow()</span><span class="c2">, </span><span class="c0 c7">bar.getClose()))</span></p><p class="c4 c5"><span class="c7 c31 c44"></span></p><p class="c4"><span class="c7 c24">Loading data ...</span></p><p class="c4"><span class="c24 c7">Running strategy ...</span></p><p class="c4"><span class="c24 c7">2016-01-04 00:00:00 strategy [INFO] open : 4.58, high : 4.59, low : 4.44, close : 4.45</span></p><p class="c4"><span class="c24 c7">2016-01-05 00:00:00 strategy [INFO] open : 4.42, high : 4.51, low : 4.38, close : 4.47</span></p><p class="c4"><span class="c24 c7">2016-01-06 00:00:00 strategy [INFO] open : 4.45, high : 4.52, low : 4.45, close : 4.51</span></p><p class="c4"><span class="c24 c7">2016-01-07 00:00:00 strategy [INFO] open : 4.49, high : 4.50, low : 4.42, close : 4.43</span></p><p class="c4 c5"><span class="c7 c31 c44"></span></p><h3 class="c17" id="h.5f37qg5cedbi"><span class="c19 c7">4.2 calculate the indicators and print </span></h3><p class="c4"><span class="c20 c18">def </span><span class="c38">__init__</span><span class="c0">(self</span><span class="c2">, </span><span class="c0">feed</span><span class="c2">, </span><span class="c0 c7">instrument):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.__instrument = instrument[</span><span class="c8">0</span><span class="c0 c7">]</span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;self.__close = feed[self.__instrument].getCloseDataSeries()</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c20 c18">def </span><span class="c33 c18">onBars</span><span class="c0">(self</span><span class="c2">, </span><span class="c0 c7">bars):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;bar = bars[self.__instrument]</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.info(</span><span class="c32">&#39;open : %.2f, high : %.2f, low : %.2f, close : %.2f&#39; </span><span class="c0 c7">%</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(bar.getOpen()</span><span class="c2">, </span><span class="c0">bar.getHigh()</span><span class="c2">, </span><span class="c0">bar.getLow()</span><span class="c2">, </span><span class="c0 c7">bar.getClose()))</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;sma_short = indicator.SMA(self.__close</span><span class="c2">, </span><span class="c8">40</span><span class="c2">, </span><span class="c28">timeperiod</span><span class="c0">=</span><span class="c8">10</span><span class="c0 c7">)</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;sma_long = indicator.SMA(self.__close</span><span class="c2">, </span><span class="c8">40</span><span class="c2">, </span><span class="c28">timeperiod</span><span class="c0">=</span><span class="c8">30</span><span class="c0 c7">)</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.info(</span><span class="c32">&#39;sma_short : %.2f, sma_long : %.2f&#39; </span><span class="c0">% (sma_short[-</span><span class="c8">1</span><span class="c0">]</span><span class="c2">, </span><span class="c0">sma_long[-</span><span class="c8">1</span><span class="c0 c7">]))</span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c13 c7">2016-02-22 00:00:00 strategy [INFO] open : 4.04, high : 4.11, low : 4.02, close : 4.08</span></p><p class="c4"><span class="c13 c7">2016-02-22 00:00:00 strategy [INFO] sma_short : 4.03, sma_long : 4.18</span></p><p class="c4"><span class="c13 c7">2016-02-23 00:00:00 strategy [INFO] open : 4.08, high : 4.08, low : 4.03, close : 4.05</span></p><p class="c4"><span class="c13 c7">2016-02-23 00:00:00 strategy [INFO] sma_short : 4.03, sma_long : 4.16</span></p><p class="c4"><span class="c13 c7">2016-02-24 00:00:00 strategy [INFO] open : 4.04, high : 4.06, low : 4.02, close : 4.05</span></p><p class="c4"><span class="c13 c7">2016-02-24 00:00:00 strategy [INFO] sma_short : 4.03, sma_long : 4.15</span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">Some words about indicator:</span></p><p class="c4"><span>Indicator module contains commonly used indicators from TA-Lib, which are shown in </span><span class="c43"><a class="c47" href="https://www.google.com/url?q=http://gbeced.github.io/pyalgotrade/docs/v0.18/html/talib.html&amp;sa=D&amp;ust=1502293391215000&amp;usg=AFQjCNG_0_OsAI20VQVm_Yb_hWdhc5Zasw">http://gbeced.github.io/pyalgotrade/docs/v0.18/html/talib.html</a></span><span>. For example, to calculate sma, we use </span><span class="c18">sma_short = indicator.SMA(self.__close</span><span class="c18">, </span><span class="c18">40</span><span class="c18">, </span><span class="c18">timeperiod</span><span class="c18">=</span><span class="c18">10</span><span class="c18">)</span><span class="c3">. The first argument means that we intend to calculate the sma of close price (SequenceDataSeries), but actually we donot want to calculate sma over the past 10 years, it really takes time and we donot need that long. So the second argument indicates that we take the last 40 price data and calculate sma using period of 10 (specified by the last argument). </span></p><p class="c4"><span class="c3">Now we calculate MACD:</span></p><p class="c4"><span class="c9 c7">def __init__(self, feed, one_instrument):</span></p><p class="c4"><span class="c7 c9">&nbsp; &nbsp; self.__barDS = feed[one_instrument]</span></p><p class="c4"><span class="c9 c7">def onBars(self, bars):</span></p><p class="c4"><span class="c9 c7">&nbsp; &nbsp; macd, macd_signal, macd_hist = indicator.MACD(self.__barDS, 50,</span></p><p class="c4"><span class="c9 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fastperiod=12, slowperiod=26, signalperiod=9)</span></p><p class="c4"><span>50 means that we fetch the last 50 data points to calculate the MACD. </span></p><h3 class="c17" id="h.bkyh53behkt"><span class="c19 c7">4.3 generate the trading signals and print</span></h3><p class="c4"><span class="c20 c18">def </span><span class="c38">__init__</span><span class="c0">(self</span><span class="c2">, </span><span class="c0">feed</span><span class="c2">, </span><span class="c0 c7">instrument):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.__instrument = instrument[</span><span class="c8">0</span><span class="c0 c7">]</span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;self.__close = feed[self.__instrument].getCloseDataSeries()</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c20 c18">def </span><span class="c18 c33">onBars</span><span class="c0">(self</span><span class="c2">, </span><span class="c0 c7">bars):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;bar = bars[self.__instrument]</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.info(</span><span class="c32">&#39;open : %.2f, high : %.2f, low : %.2f, close : %.2f&#39; </span><span class="c0 c7">%</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(bar.getOpen()</span><span class="c2">, </span><span class="c0">bar.getHigh()</span><span class="c2">, </span><span class="c0">bar.getLow()</span><span class="c2">, </span><span class="c0 c7">bar.getClose()))</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;sma_short = indicator.SMA(self.__close</span><span class="c2">, </span><span class="c8">40</span><span class="c2">, </span><span class="c28">timeperiod</span><span class="c0">=</span><span class="c8">10</span><span class="c0 c7">)</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;sma_long = indicator.SMA(self.__close</span><span class="c2">, </span><span class="c8">40</span><span class="c2">, </span><span class="c28">timeperiod</span><span class="c0">=</span><span class="c8">30</span><span class="c0 c7">)</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.info(</span><span class="c32">&#39;sma_short : %.2f, sma_long : %.2f&#39; </span><span class="c0">% (sma_short[-</span><span class="c8">1</span><span class="c0">]</span><span class="c2">, </span><span class="c0">sma_long[-</span><span class="c8">1</span><span class="c0 c7">]))</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;curr_pos = self.getBroker().getShares(self.__instrument)</span></p><p class="c4"><span class="c0 c7">&nbsp; </span></p><p class="c4"><span class="c0">&nbsp; &nbsp;</span><span class="c20 c18">if </span><span class="c0">curr_pos == </span><span class="c8">0 </span><span class="c18 c20">and </span><span class="c0">sma_short[-</span><span class="c8">1</span><span class="c0">] &lt; (</span><span class="c8">1.00 </span><span class="c0">+ </span><span class="c8">0.01</span><span class="c0">) * sma_long[-</span><span class="c8">1</span><span class="c0 c7">]:</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;self.info(</span><span class="c32">&#39;can open long position&#39;</span><span class="c0 c7">)</span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c13 c7">2016-03-09 00:00:00 strategy [INFO] open : 4.28, high : 4.42, low : 4.26, close : 4.41</span></p><p class="c4"><span class="c13 c7">2016-03-09 00:00:00 strategy [INFO] sma_short : 4.17, sma_long : 4.10</span></p><p class="c4"><span class="c13 c7">2016-03-09 00:00:00 strategy [INFO] can open long position</span></p><p class="c4 c5"><span class="c3"></span></p><h3 class="c17" id="h.e8haxseguhlb"><span class="c19 c7">4.4 order placement</span></h3><p class="c4"><span class="c20 c18">def </span><span class="c38">__init__</span><span class="c0">(self</span><span class="c2">, </span><span class="c0">feed</span><span class="c2">, </span><span class="c0 c7">instrument):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;self.__instrument = instrument[</span><span class="c8">0</span><span class="c0 c7">]</span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;self.__close = feed[self.__instrument].getCloseDataSeries()</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c20 c18">def </span><span class="c33 c18">onBars</span><span class="c0">(self</span><span class="c2">, </span><span class="c0 c7">bars):</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;bar = bars[self.__instrument]</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;sma_short = indicator.SMA(self.__close</span><span class="c2">, </span><span class="c8">40</span><span class="c2">, </span><span class="c28">timeperiod</span><span class="c0">=</span><span class="c8">10</span><span class="c0 c7">)</span></p><p class="c4"><span class="c0">&nbsp; &nbsp;sma_long = indicator.SMA(self.__close</span><span class="c2">, </span><span class="c8">40</span><span class="c2">, </span><span class="c28">timeperiod</span><span class="c0">=</span><span class="c8">30</span><span class="c0 c7">)</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;curr_price = bar.getClose()</span></p><p class="c4"><span class="c0 c7">&nbsp; &nbsp;curr_pos = self.getBroker().getShares(self.__instrument)</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;</span><span class="c7 c22"># stop loss when cross of sma_short and sma_long</span></p><p class="c4"><span class="c22">&nbsp; &nbsp;</span><span class="c20 c18">if </span><span class="c0">curr_pos != </span><span class="c8">0</span><span class="c0 c7">:</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20 c18">if </span><span class="c0">(sma_short[-</span><span class="c8">1</span><span class="c0">] - sma_long[-</span><span class="c8">1</span><span class="c0">]) * (sma_short[-</span><span class="c8">2</span><span class="c0">] - sma_long[-</span><span class="c8">2</span><span class="c0">]) &lt; </span><span class="c8">0</span><span class="c0 c7">:</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.marketOrder(self.__instrument</span><span class="c2">, </span><span class="c0">-</span><span class="c8">1 </span><span class="c0">* curr_pos</span><span class="c2">, </span><span class="c28">goodTillCanceled</span><span class="c0">=</span><span class="c44 c51">True</span><span class="c0 c7">)</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c0">&nbsp; &nbsp;</span><span class="c22 c7"># The trading logic, actually it is mean-reversion</span></p><p class="c4"><span class="c22">&nbsp; &nbsp;</span><span class="c20 c18">if </span><span class="c0">curr_pos == </span><span class="c8">0 </span><span class="c20 c18">and </span><span class="c0">sma_short[-</span><span class="c8">1</span><span class="c0">] &lt; (</span><span class="c8">1.00 </span><span class="c0">- </span><span class="c8">0.01</span><span class="c0">) * sma_long[-</span><span class="c8">1</span><span class="c0 c7">]:</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;shares = </span><span class="c51 c44">int</span><span class="c0">(self.getBroker().getCash() * </span><span class="c8">0.9 </span><span class="c0 c7">/ curr_price)</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;self.marketOrder(self.__instrument</span><span class="c2">, </span><span class="c0">shares</span><span class="c2">, </span><span class="c28">goodTillCanceled</span><span class="c0">=</span><span class="c51 c44">True</span><span class="c0 c7">)</span></p><p class="c4 c5"><span class="c0 c7"></span></p><p class="c4"><span class="c13 c7">Loading data ...</span></p><p class="c4"><span class="c13 c7">Running strategy ...</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 2, 22, 0, 0), &#39;601398.SH&#39;, &#39;B&#39;, 22388, 4.040000011670854, 90.44752026128708)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 3, 8, 0, 0), &#39;601398.SH&#39;, &#39;S&#39;, 22388, 4.259999992560814, 95.3728798334515)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 5, 18, 0, 0), &#39;601398.SH&#39;, &#39;B&#39;, 22180, 4.250000061039924, 94.26500135386551)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 5, 30, 0, 0), &#39;601398.SH&#39;, &#39;S&#39;, 22180, 4.289999970454204, 95.15219934467424)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 7, 21, 0, 0), &#39;601398.SH&#39;, &#39;B&#39;, 22171, 4.280000037735797, 94.89188083664035)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 8, 15, 0, 0), &#39;601398.SH&#39;, &#39;S&#39;, 22171, 4.509999993910131, 99.9912098649815)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 9, 27, 0, 0), &#39;601398.SH&#39;, &#39;B&#39;, 22518, 4.410000106994311, 99.3043824092979)</span></p><p class="c4"><span class="c7 c13">(&#39;guowen&#39;, datetime.datetime(2016, 11, 2, 0, 0), &#39;601398.SH&#39;, &#39;S&#39;, 22518, 4.419999929982253, 99.52955842334036)</span></p><p class="c4"><span class="c13 c7">(&#39;guowen&#39;, datetime.datetime(2016, 12, 28, 0, 0), &#39;601398.SH&#39;, &#39;B&#39;, 22626, 4.390000026093601, 99.32814059039382)</span></p><p class="c4"><span class="c13 c7">Preparing output ...</span></p><p class="c4"><span class="c13 c7">Finished</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 460.50px; height: 374.89px;"><img alt="" src="images/image2.png" style="width: 460.50px; height: 374.89px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c25" id="h.q1v7tyj08fu"><span class="c12 c7">5 multi-instrument strategy!</span></h2><p class="c4"><span class="c3">Having tried single instrument strategy, let&rsquo;s play with multi-instrument strategy.</span></p><p class="c4"><span class="c34">frequency</span><span class="c1">&nbsp;= </span><span class="c16 c7">&#39;DAY&#39;</span></p><p class="c4"><span class="c1">start = </span><span class="c7 c16">&#39;2016-01-01&#39;</span></p><p class="c4"><span class="c1">end = </span><span class="c16">&#39;2017-07-01&#39;</span></p><p class="c4"><span class="c1">instrument = [</span><span class="c16">&#39;au.SHF&#39;</span><span class="c23">, </span><span class="c16">&#39;ag.SHF&#39;</span><span class="c1 c7">]</span></p><p class="c4"><span class="c1">cash = </span><span class="c10 c7">100000.0</span></p><p class="c4"><span class="c1">user_id = </span><span class="c16 c7">&#39;guowen&#39;</span></p><p class="c4"><span class="c1">commission = </span><span class="c10 c7">0.001</span></p><p class="c4"><span class="c1">slippage = </span><span class="c10 c7">0.1</span></p><p class="c4 c5"><span class="c10 c7"></span></p><p class="c4"><span class="c3">These are the parameters: we implement one pair trade strategy with futures au and ag. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c23">def </span><span class="c37">__init__</span><span class="c1">(self</span><span class="c23">, </span><span class="c1">feed</span><span class="c23">, </span><span class="c1 c7">instrument):</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span class="c1 c7">&nbsp; &nbsp;self.__instrument = instrument</span></p><p class="c4"><span class="c1 c7">&nbsp; &nbsp;self.__close = {}</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c23">for </span><span class="c1">ele </span><span class="c23">in </span><span class="c1 c7">self.__instrument:</span></p><p class="c4"><span class="c1 c7">&nbsp; &nbsp; &nbsp; &nbsp;self.__close[ele] = feed[ele].getCloseDataSeries()</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span class="c1">&nbsp; &nbsp;self.__half_cash = self.getBroker().getCash() / </span><span class="c10 c7">2.0</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;</span><span class="c1">self.__thr_close = </span><span class="c10 c7">2.0</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;</span><span class="c1">self.__thr_open = -</span><span class="c10 c7">2.0</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;</span><span class="c1">self.__window = </span><span class="c10 c7">30</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;</span><span class="c1">self.__loop = </span><span class="c10 c7">0</span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span>In </span><span class="c18">__init__</span><span class="c3">, we declare the data and class variables we will use in each loop, including:</span></p><p class="c4"><span>The close price: </span><span class="c18">self.__close</span><span class="c3">, which is a dict mapping insrument to SequenceDataSeries </span></p><p class="c4"><span class="c3">Half of the cash is used to long one instrument while the other half is used to short the other instrument.</span></p><p class="c4"><span class="c18">self.__thr_open</span><span>&nbsp;and </span><span class="c18">self.__thr_close</span><span class="c3">&nbsp;are the threshold to open and close positions. </span></p><p class="c4"><span class="c18">self.__window</span><span class="c3">&nbsp;is the window used to calculate the indicator. </span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4"><span class="c3">In each loop, we do the following things:</span></p><p class="c4"><span class="c15">def </span><span class="c18 c46">onBars</span><span class="c1">(self</span><span class="c23">, </span><span class="c1 c7">bars):</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c36 c7"># user defined strategy</span></p><p class="c4"><span class="c36">&nbsp; &nbsp;</span><span class="c15">if </span><span class="c1">self.__loop &lt; self.__window-</span><span class="c10">1</span><span class="c1 c7">:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;self.__loop += </span><span class="c10 c7">1</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15 c7">return</span></p><p class="c4 c5"><span class="c15 c7"></span></p><p class="c4"><span>Historical data for au and ag:</span></p><p class="c4"><span class="c15">&nbsp; &nbsp;</span><span class="c1">au_hist = np.asarray(self.__close[self.__instrument[</span><span class="c10">0</span><span class="c1 c7">]][-self.__window:])</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;ag_hist = np.asarray(self.__close[self.__instrument[</span><span class="c10">1</span><span class="c1 c7">]][-self.__window:])</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span>Linear regression between au(x) and ag(y), then rsd is the difference between ag and the amplified au, finally we calculate how large the today&rsquo;s difference is by dividing std of rsd</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;eff = np.polyfit(au_hist</span><span class="c23">, </span><span class="c1">ag_hist</span><span class="c23">, </span><span class="c10">1</span><span class="c1 c7">)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;rsd = ag_hist - (au_hist * eff[</span><span class="c10">0</span><span class="c1">] + eff[</span><span class="c10">1</span><span class="c1 c7">])</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;ratio = np.asscalar(rsd[-</span><span class="c10">1</span><span class="c1 c7">] / np.std(rsd))</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span>The current position of au and ag </span></p><p class="c4"><span class="c1">&nbsp; &nbsp;au_posi = self.getBroker().getShares(self.__instrument[</span><span class="c10">0</span><span class="c1 c7">])</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;ag_posi = self.getBroker().getShares(self.__instrument[</span><span class="c10">1</span><span class="c1 c7">])</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span>The current price of au and ag </span></p><p class="c4"><span class="c1">&nbsp; &nbsp;au_close = bars[self.__instrument[</span><span class="c10">0</span><span class="c1 c7">]].getClose()</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;ag_close = bars[self.__instrument[</span><span class="c10">1</span><span class="c1 c7">]].getClose()</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span class="c3">The trading logic: </span></p><p class="c4"><span>If ratio &gt; self.__thr_close: close all positions</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c36 c7"># check for close position</span></p><p class="c4"><span class="c36">&nbsp; &nbsp;</span><span class="c15">if </span><span class="c1">au_posi != </span><span class="c10">0 </span><span class="c15">or </span><span class="c1">ag_posi != </span><span class="c10">0</span><span class="c1 c7">:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if </span><span class="c1 c7">ratio &gt; self.__thr_close:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.marketOrder(self.__instrument[</span><span class="c10">0</span><span class="c1">]</span><span class="c23">, </span><span class="c1">-</span><span class="c10">1 </span><span class="c1">* au_posi</span><span class="c23">, </span><span class="c21">goodTillCanceled</span><span class="c1">=</span><span class="c11">True</span><span class="c1 c7">)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.marketOrder(self.__instrument[</span><span class="c10">1</span><span class="c1">]</span><span class="c23">, </span><span class="c1">-</span><span class="c10">1 </span><span class="c1">* ag_posi</span><span class="c23">, </span><span class="c21">goodTillCanceled</span><span class="c1">=</span><span class="c11">True</span><span class="c1 c7">)</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4"><span>If ratio &lt; self.__thr_open: short au and long ag</span></p><p class="c4"><span class="c1">&nbsp; &nbsp;</span><span class="c36 c7"># check for open position</span></p><p class="c4"><span class="c36">&nbsp; &nbsp;</span><span class="c15">if </span><span class="c1">au_posi == </span><span class="c10">0 </span><span class="c15">and </span><span class="c1">ag_posi == </span><span class="c10">0</span><span class="c1 c7">:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if </span><span class="c1 c7">ratio &lt; self.__thr_open:</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shares0 = </span><span class="c11">int</span><span class="c1">(self.__half_cash * </span><span class="c10">0.9 </span><span class="c1 c7">/ au_close)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.marketOrder(self.__instrument[</span><span class="c10">0</span><span class="c1">]</span><span class="c23">, </span><span class="c1">-</span><span class="c10">1 </span><span class="c1">* shares0</span><span class="c23">, </span><span class="c21">goodTillCanceled</span><span class="c1">=</span><span class="c11">True</span><span class="c1 c7">)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shares1 = </span><span class="c11">int</span><span class="c1">(self.__half_cash * </span><span class="c10">0.9 </span><span class="c1 c7">/ ag_close)</span></p><p class="c4"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;self.marketOrder(self.__instrument[</span><span class="c10">1</span><span class="c1">]</span><span class="c23">, </span><span class="c1">shares1</span><span class="c23">, </span><span class="c21">goodTillCanceled</span><span class="c1">=</span><span class="c11">True</span><span class="c1 c7">)</span></p><p class="c4 c5"><span class="c1 c7"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p><p class="c4 c5"><span class="c3"></span></p></body></html>